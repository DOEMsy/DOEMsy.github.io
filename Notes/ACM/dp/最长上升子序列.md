# 最长上升子序列 LIS

## 最长上升子序列 LIS

若子序列长度相同，则尾元素越小的越有添加元素增长的优势

$d p[i]$为长度为$i+1$的上升序列中尾元素的最小值（不存在为$INF$）

状态方程	$dp[i] = min\{canin(i)\}$ 在维护的时候有如下两种情况

```C++
    7↓
    2 3 6 = 2 3 6 7 INF....    扩充
    4↓
    2 3 6 7 = 2 3 4 7 INF...	更替
```

$\\$

```c++
fill(dp,dp+n,INF)
for(int i=0;i<n;i++)
	*lower_bound(dp,dp+n,a[i]) = a[i];

cout<<  lower_bound(dp,dp+n,INF) - dp  <<endl
```

最终$dp$数组并不是其中一个最长上升子序列，但其长度（最后一个有效值的下一个位置，即end位置，此点也是第一个INF）是最长子序列的长度

复杂度$Onlog n$

*子序列不是连续子序列，而且其中不包括等于*

$\\$

### 记录序列

上面的方法不能记录结果序列，如果要求出整个序列，需要加以标记

$\\$

## 最长不下降子序列 LnIS

最长不下降子序列表示序列中可以存在相等

```
	6↓
    2 3 6 = 2 3 6 6		扩充
    4↓
    2 3 6 7 = 2 3 4 7	更替
```

$\\$

```C++
fill(dp,dp+n,INF)
for(int i=0;i<n;i++)
	*upper_bound(dp,dp+n,a[i]) = a[i];

cout<<  lower_bound(dp,dp+n,INF) - dp  <<endl	//这里没有写错，寻找最后一个有效值的下一个位置
```

 与最长上升子序列同理

$\\$

## 最长下降子序列的个数 count(LDS)

根据Dilworth定理：在一个序列中最长下降子序列的个数就等于其最长不下降子序列的长度

即  $count(LDS) = len(LnIS)$

（下面都是我猜的）

*   $count(LnDS) = len(LIS)$
*   $count(LIS) = len(LnDS)$
*   $count(LnIS) = len(LDS)$

$注：LnIS = Longest$  $non-Increase Sequence$

$\\$

## 最长下降子序列 LDS

假如我们突然有一道抽风题，需要求LDS的长度

不要慌，我们只需要修改世界法则即可X

把 $lower\_bound$ 的比较方式颠倒一下

```C++
lower/upper_bound 会在比较函数为false时停止
查询的比较函数需要与序列排序相同
lower不带等号，upper带等号

fill(dp,dp+n,-INF)
for(int i=0;i<n;i++)
    *lower_bound(dp,dp+n,a[i],[](int a,int b){
       return a>b; 
    }) = a[i];

cout<<  lower_bound(dp,dp+n,-INF,[](int a,int b){
    return a>b; 
}) - dp  <<endl

/****************************************************************
	lower_bound(b)
	   ↓
.. c c b b b ..
*****************************************************************/
```

如果在 $lower\_bound$ 的比较方式上加个“ = ” 就会变成 $upper\_bound$ 的功能（无卵用）

```C++
lower_bound(a,a+n,value,[](int a,int b){
	return a<=b; 
})

upper_bound(a,a+n,value);

/****************************************************************
	lower_bound(b),upper_bound(b)
	  	   	 ↓
.. a a b b b c ..
*****************************************************************/
```

