# Lc153 乘积最大子序列

给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。

>   示例 1:
>
>   输入: [2,3,-2,4]
>
>   输出: 6
>
>   解释: 子数组 [2,3] 有最大乘积 6。

$\\$

>   示例 2:
>
>   输入: [-2,0,-1]
>
>   输出: 0
>
>   解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。

## 解题

### 尺取

首先看到的第一反应是尺取，尺取可以很简单的达到$On$，但是尺取需要一个下限条件，诸如序列长度最低为$m$或者乘积值大于$p$之类的来降低常数，而且尺取只能用来寻找与所选序列长度成线性相关的结果，通常寻找的是最低限值。

所以此题无法尺取求解

### dp

我们可以把这道题当背包来做，万物皆可背包

>   当前待选数字下标为$i$，有一种转移方向，以当前下标数字为结尾的序列最值为$max_i,min_i$
>
>   *   选择该数字		$max_i = max(max_i,max_{i-1}*num_i)$
>   *   不选择该数字	$max_i =max(max_i,num_i)$
>
>   合并为$max_i = max(max_{i-1}*num_i,num_i)$
>
>   然后选取 $ans  = max(max_i)$

但是值得注意的序列中存在负数，我们需要同时考虑最小值，最小值有可能乘上负数后变成了最大值，而且同时最大值可能乘以负数后变成了最小值。

>   $max_i = max\{max_{i-1}*num_i,min_{i-1}*num_i,num_i\}$
>
>   $min_i = min\{max_{i-1}*num_i,min_{i-1}*num_i,num_i\}$

又因为当$num_i<0$时

$max_{i-1}>=min{i-1}$		===>		$max_{i-1}*num_i<=min_{i-1}*num_i$	

所以上列式子可以优化为

当$num_i>=0$时

>   $max_i = max(max_{i-1}*num_i,num_i)$
>
>   $min_i = min(min_{i-1}*num_i,num_i)$

当$num_i<0$时

>   $max_i = max(min_{i-1}*num_i,num_i)$
>
>   $min_i = min(max_{i-1}*num_i,num_i)$

最后答案$ans = max(max_i)$

```C++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int ans = -99999;
        int maxi = 1;
        int mini = 1;
        int n = nums.size();
        for(int i=0;i<n;i++){
            if(nums[i]<0)   swap(maxi,mini);
            maxi = max(maxi*nums[i],nums[i]);
            mini = min(mini*nums[i],nums[i]);
 

            ans = max(maxx,maxi);
        }

        return ans;
    }
};
```

