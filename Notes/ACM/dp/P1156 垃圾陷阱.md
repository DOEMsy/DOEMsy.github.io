# P1156 垃圾陷阱

## 题目描述

卡门――农夫约翰极其珍视的一条`Holsteins`奶牛――已经落了到“垃圾井”中。“垃圾井”是农夫们扔垃圾的地方，它的深度为$D(2≤D≤100)$英尺。

卡门想把垃圾堆起来，等到堆得与井同样高时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。

每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。

假设卡门预先知道了每个垃圾扔下的时间$t(0<t≤1000)$，以及每个垃圾堆放的高度$h(1≤h≤25)$和吃进该垃圾能维持生命的时间$f(1≤f≤30)$，要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续10小时的能量，如果卡门10小时内没有进食，卡门就将饿死。

## 输入格式

第一行为2个整数，*D*和*G*(1≤*G*≤100)，*G*为被投入井的垃圾的数量。

第二到第*G+1*行每行包括3个整数：*T*(0<*T*<=1000)，表示垃圾被投进井中的时间；*F*(1≤*F*≤30)，表示该垃圾能维持卡门生命的时间；和 *H*(1≤*H*≤25)，该垃圾能垫高的高度。

## 输出格式

如果卡门可以爬出陷阱，输出一个整表示最早什么时候可以爬出；否则输出卡门最长可以存活多长时间。

## 样例

输入

```
20 4
5 4 9
9 3 2
12 6 10
13 1 1
```

输出

```
13
```

## 说明/提示

[样例说明]

堆放第1个垃圾 $height=9$

吃到第2个垃圾 生命值从10小时延长到13小时

堆放第3个垃圾 $height = 19$

堆放第4个垃圾 $height = 20$

## 解题

读完题之后大概思路为背包$dp$，递推的状态有三个因素：等待的垃圾，当前高度，当前生命

起初有两种递推方案：

#### 方案1 

$dp[i][j]$，表示在等待第$i$个垃圾时候的当前生命值为$j$的最高高度，设当前垃圾提供的生命值为$f_i$，提供的高度为$h_i$，投放时间为$t_i$

>   如果$j>=t_i$，即可以活着等到，则有如下状态转移
>
>   *   $dp[i+1][j+f_i] = max(dp[i+1][j+f_i],dp[i][j])$	吃掉之后的状态
>   *   $dp[i+1][j] = max(dp[i+1][j],dp[i][j]+h_i)$   	垫高之后的状态		
>
>   最后满足$dp[G][j]>=D$的最小$j$为最短逃离天数
>
>   否者满足$dp[G][j]==0$的最大$j$为最长存活时间，即$\sum_{i=1}^Gf_i$

#### 方案2

$dp[i][j]$，表示在等待第$i$个垃圾时候的当前高度为$j$的最大生命，设当前垃圾提供的生命值为$f_i$，提供的高度为$h_i$，投放时间为$t_i$

>   如果$dp[i][j]>=t_i$，即可以活着等到，则有如下状态转移
>
>   *   $dp[i+1][j] = max(dp[i+1][j],dp[i][j]+f_i)$	吃掉之后的状态
>   *   $dp[i+1][j+h_i] = max(dp[i+1][j+h_i],dp[i][j])$   垫高之后的状态
>
>   最后满足$j>=D$的最小$dp[i][j]$最短逃离天数
>
>   否者$dp[G][0]$为最长存活时间，全吃掉

由于我们的时间和高度都是递增变化的，所以第一次出现$j+h_i>=D$的$t_i$即为所求

而且遍历生命最大可能会达到$max(t_i)=1000$，同时不好判断

而到达高度作为终止条件，遍历范围最大只有$max(D) = 200$

所以我们选择方案2

```C++
#include<bits/stdc++.h>
#define ll long long
#define fr(i,n) for(int i=0;i<n;i++)
#define frr(i,j,n) for(int i=j;i<n;i++)
#define yes "yes"
#define no  "no"
using namespace std;

struct node{
    int T,F,H;
}nodes[105];

int dp[2][205];//等待这个垃圾时 当前高度下 最高生命

/*
    如果在某件垃圾扔下的需要时间大于等于当前垃圾的最高生命值时->无法爬出
    否者可以捡到这个垃圾

        dp[i] 等待状态
        nodes[i] 被等待垃圾
        dp[i+1] 接受完成状态

*/

int main(){

    //ios::sync_with_stdio(false);
    cin.tie(0);
    int D,G;
    while(cin>>D>>G){
        fr(i,G){
            cin>>nodes[i].T>>nodes[i].F>>nodes[i].H;
        }

        sort(nodes,nodes+G,[](node a,node b){
            return a.T<b.T;
        });


        fr(i,2) fill(dp[i],dp[i]+200,-1);
        dp[0][0] = 10;
        int maxi = dp[0][0];
        bool can = false;
        fr(i,G){
            fr(j,D+1){
                //在等待第i个垃圾 高度为j时 生命值可以活着等到
                if(nodes[i].T<=dp[i&1][j]){
                    if(j+nodes[i].H>=D){    //直接走出去了
                        can = true;
                        cout<<nodes[i].T<<endl;
                        goto loop;
                    }

                    dp[!(i&1)][j+nodes[i].H] = max(
                        dp[!(i&1)][j+nodes[i].H],
                        dp[i&1][j]
                    ); //堆起来
                    dp[!(i&1)][j] = max(
                        dp[!(i&1)][j],
                        dp[i&1][j]+nodes[i].F
                    );  //吃掉
                }
            }
            maxi = max(maxi,dp[!(i&1)][0]);
        }

        loop:
        //没有出现到达
        if(!can){
            //当然全吃掉活的最久
            /*
                dp[i] 等待状态
                nodes[i] 被等待垃圾
                dp[i+1] 接受完成状态
            */
            cout<<maxi<<endl;
        }
    }

    return 0;
}

```

