# Lc560. 和为K的子数组

给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。

#### 示例 1 :

输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。

#### 说明 :

数组的长度为 [1, 20,000]。
数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。

## 解题

### 尺取

对于这种线性表求一段的题目，第一反应是尺取。

但是数组中的数字含有负数，导致子数组长度与其和不成单调相关

所以尺取不行

### hash+前缀和

既然尺取不行，我们采用另一种优化，前缀和，$sum_n = \sum_{i=0}^{n-1}a_i$

对于当前位置前缀和$sum_i$来说，前面的前缀和$sum_j$，如果$sum_i-sum_j = sum[j,i) = k$则$[j,i)$这个区间段满足题意

那么我们只需要维护并累加满足$sum_j==sum_i-k$的数量即可，这个过程使用$hash$表进行优化

```C++
class Solution {
public:
#include<bits/stdc++.h>
#define ll long long

#define fr(i,n) for(int i=0;i<n;i++)
#define frs(i,n,flag)   for(int i=0;i<n&&flag;i++)


#define frr(i,j,n) for(int i=j;i<n;i++)
#define r_frr(i,j,n) for(int i=n-1;i>=j;i--)

#define frrs(i,j,n,flag)    for(int i=j;i<n&&flag;i++)
#define r_frrs(i,j,n,flag)    for(int i=n-1;i>=j&&flag;i--)


#define yes "yes"
#define no  "no"

    int subarraySum(vector<int>& nums, int k) {
        ll sum = 0;
        ll ans = 0;
        unordered_map<int,int>dp;dp[0] = 1;
        int n = nums.size();
        fr(i,n){
            sum = sum+nums[i];
            auto it = dp.find(sum-k);
            ans += it==dp.end()?0:it->second;
            dp[sum]++;
        }

        return ans;
    }
};
```

