# 线段树

将一条线段用二叉树分成一些段值存储

用于**快速查询(Inquire)**或**更新段值(Update)**

### 建树

**父亲的区间是[a,b],(c=(a+b)/2)左儿子的区间是[a,c]，右儿子的区间是[c+1,b]，线段树需要的空间为数组大小的四倍**

```cpp
#define Tree_Max_Size 10005
struct segment_tree_node{
    int l,r;
    int w;
    int lazy;	//lazy标记
};
segment_tree_node tree[Tree_Max_Size];

void Build(int l,int r,int v=0,int k = 1){
    tree[k].l=l;
    tree[k].r=r;
    tree[k].lazy=0;
    if(l==r){
        tree[k].w=v;
    }else{
        Build(l,(l+r)>>1,k<<1);
        Build((l+r)/>>1|1,r,k<<1|1);
        tree[k].w = PushUp(tree[k<<1].w,tree[k<<1|1].w);
    }
}
```



### 区间修改

```c++
void Update(int l,int r,int w,int k = 1){
    /*lazy*/
    if(tree[k].l==l&&tree[k].r==r){
        //只更新大段
        tree[k].w += w;
        //子段的更新存入缓存等需要的时候再进行
        tree[k].lazy += w;
    }else if(tree[k].l==tree[k].l){
        //到达叶子
        tree[k].w += w;
    }else{
        PushDown(k);
        int mid = (tree[k].l+tree[k].r)>>1;
        if(l<=mid)
            Update(l,mid,w,k<<1);
        if(mid+1<=r)
            Update(mid+1,r,w,k<<1|1);
        tree[k].w = PushUp(tree[k<<1].w,tree[k<<1|1].w);
    }
}
```



### 查询

```c++
int Inquire(int l,int r,int k = 1){
    if(tree[k].l==l&&tree[k].r==r){
        return tree[k].w;
    }else if(tree[k].l==tree[k].r){
        return tree[k].w;
    }else{
        PushDown(k);
        int mid = (tree[k].l+tree[k].r)>>1;
        int lw = 0,rw = 0;
        if(l<=mid)
            lw = Inquire(l,mid,k<<1);
        if(mid+1<=r)
            rw = Inquire(mid+1,r,k<<1|1);
        return PushUp(lw,rw);
    }
}
```

### 下推和上推

```c++
/*PushDown 更新子段的值和lazy*/
void PushDown(int k){
    //将lazy向下传递
    tree[k<<1].lazy += tree[k].lazy;
    tree[k<<1].w += tree[k].lazy;
    tree[k<<1|1].lazy += tree[k].lazy;
    tree[k<<1|1].w += tree[k].lazy;
    //清空传递完的lazy
    tree[k].lazy = 0;
}
/*PushUp*/
int PushUp(int w1,int w2){
    //return w1+w2;
    //return w1*w2;
    return max(w1,w2);
}
```

---





