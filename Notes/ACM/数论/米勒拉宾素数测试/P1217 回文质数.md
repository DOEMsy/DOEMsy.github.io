# P1217 回文质数

## 题目描述

因为 151 既是一个质数又是一个回文数（从左到右和从右到左是看一样的），所以 151 是回文质数。

写一个程序来找出范围 $[a,b] (5 \le a < b \le 100,000,000)$( 一亿)间的所有回文质数。

## 输入格式

第 1 行: 二个整数 a 和 b .

## 输出格式

输出一个回文质数的列表，一行一个。

## 输入输出样例

**输入 #1**

```
5 500
```

**输出 #1**

```
5
7
11
101
131
151
181
191
313
353
373
383
```

## 解题

看到素数区间查询，第一个想到的就是素数筛打表，但是1e8刚好越界，我们必须采用其他打表方法

题目中只需要记录所有是回文数的素数就行，首先以遍历回文数为切入点

### 初始方案

从1遍历到1e8，判断回文数再判断素数

或者先判断素数再判断回文数

这两个复杂度$O(n^{3/2})$起点，很明显会超时

### 优化

首先是对回文数的优化，从1遍历到1e4，再做对称可以得到1e8以内的全部回文数，复杂度$O(\sqrt n)$

125 -> 125521 , 12521

其次使用米勒拉宾素数判定，复杂度$O(1)$

将回文素数推入表中，但是注意我们的结果并不是有序排列的，所以在查询之前要先排序

最终复杂度$O(\sqrt n)$

```C++
#include<bits/stdc++.h>
#define ll long long

#define fr(i,n) for(int i=0;i<n;i++)
#define frs(i,n,flag)   for(int i=0;i<n&&flag;i++)

#define frr(i,j,n) for(int i=j;i<n;i++)
#define r_frr(i,j,n) for(int i=n-1;i>=j;i--)

#define frrs(i,j,n,flag)    for(int i=j;i<n&&flag;i++)
#define r_frrs(i,j,n,flag)    for(int i=n-1;i>=j&&flag;i--)


#define yes "yes"
#define no  "no"

#define arend(i,n) ((i!=n-1)?" ":"\n")
#define memset0(dp) memset(dp,0,sizeof(dp))
#define min_get(a,b) a = min(a,b)
#define max_get(a,b) a = max(a,b)
#define PI  3.14159265354

#define print_arr(begin,end)    for(auto it = begin;it!=end;it++)  cout<<*it<<arend(it,end);
#define log_this(name,value)    cout<<name<<": "<<value<<endl;

#define e5 100005
#define e6 1000006
#define INF 9999999
using namespace std;
int     to_int(string s)    {stringstream ss;ss<<s;int a;ss>>a;return a;}
string  to_str(double a)    {stringstream ss;ss<<a;return ss.str();}

ll qPow(ll a,ll b,ll p = 1){
    if(!b)  return 1;
    ll ans = 1;
    while(b){
        if(b&1) ans = (ans*a)%p;
        b>>=1;  a = (a*a)%p;
    }
    return ans;
}

bool isprime(ll p){
    if(p==1||(!p&1))    return false;

    bool flag = true;
    frs(i,200,flag){
        int a = 0;
        while(!a)   a = rand()%p;

        if( qPow(a,p-1,p)!=1 )	flag = false;
    }
    return flag;
}

int oup[100000];
int tail;
int main(){

    cin.tie(0);
    //ios::sync_with_stdio(false);
    cout<<setiosflags(ios::fixed)<<setprecision(0);

    tail = 0;
    frr(i,1,10001){
        //制作回文数
        string p = to_str(i);
        string x1 = p,x2 = p;
        reverse(p.begin(),p.end());
        x1+=p;
        x2+=p.substr(1);
        
        //素性判定
        int o1 = to_int(x1);
        int o2 = to_int(x2);
        if(isprime(o1)) oup[tail++] = o1;
        if(isprime(o2)) oup[tail++] = o2;
    }

    sort(oup,oup+tail);

    int a,b;
    while(cin>>a>>b){
        int *begin = lower_bound(oup,oup+tail,a);
        int *end = upper_bound(oup,oup+tail,b);
        for(int *t=begin;t!=end;t++)
            cout<<*t<<endl;
    }

    return 0;
}
```

